<!DOCTYPE html>
<html>
    <canvas id="output" width="728" height="942"></canvas>

    <script id="rain" src="scripts/rain.js"></script>
    <script id="gl-matrix" src="scripts/gl-matrix.js"></script>

    <!-- SHADERS -->
    <script id="vertex-shader" type="notjs">#version 300 es
        in vec4 a_position;
        in float a_point_size;

        in vec4 in_Color;
        out vec4 v_Color;

        // transformation matrix here
        uniform mat4 u_transformation_matrix;

        // glmatrix things
        uniform mat4 model;
        uniform mat4 view;
        uniform mat4 projection;

        void main() {
            gl_Position = u_transformation_matrix * projection * view * model * a_position;
            gl_PointSize = a_point_size;

            // we basically output the input in_Color w/c will be used by frag shader
            v_Color = in_Color;
        }
    </script>

    <script id="fragment-shader" type="notjs">#version 300 es
        precision mediump float;
        
        // input will be same name as the output color name of the vshader
        in vec4 v_Color;

        // this will then apply the color thingy
        out vec4 out_Color;
        
        void main() {
            out_Color = v_Color;
        }
    </script>

    <!--MAIN-->
    <script>
        let allRain = [];

        /*
            TEMP -- PUT MODIFIABLE PARAMETERS HERE
        */
       var speed = 3;

        /*
            END OF TEMP REGION
        */


        let then = 0;

        // initialize the gl and shit
        // gets the canvas w/c we will apply the script to
        const canvas = document.querySelector("#output");
        const gl = canvas.getContext("webgl2");
        //const glMatrix = document.querySelector("gl-matrix");

        // gets the source code sa <script>s sa taas
        const vertexShaderSource = document.querySelector('#vertex-shader').textContent;
        const fragmentShaderSource = document.querySelector('#fragment-shader').textContent;

        //creates and compiles the shaders
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

        // create and initialize the gl program.
        var program = gl.createProgram();

        // attach the vertex and fragment shaders
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);

        // link the program
        gl.linkProgram(program);
        gl.useProgram(program);

        /*
            MATRIX FOR TRANSFORMING STUFF ?
        */
        let transformMatrix = [
            1,0,0,0,
            0,1,0,0,
            0,0,1,0,
            0,0,0,1
        ];

       // we create the matrices here.
        const modelMatrix = glMatrix.mat4.create();
        const viewMatrix = glMatrix.mat4.create();
        const projectionMatrix = glMatrix.mat4.create();

        /*
            POINTERS
        */

        // we can access the pointers here already
        var vertexPositionPtr = gl.getAttribLocation(program, 'a_position');
        var vertexSizePtr = gl.getAttribLocation(program, 'a_point_size');
        var vertexColorPtr = gl.getAttribLocation(program, 'in_Color');
        // for affine transformationheadVertexCount
        var transformPtr = gl.getUniformLocation(program, 'u_transformation_matrix');

        // accessing the pointers for glMatrices here
        var modelPtr = gl.getUniformLocation(program, 'model');
        var viewPtr = gl.getUniformLocation(program, 'view');
        var projectionPtr = gl.getUniformLocation(program, 'projection');

        /* 
            FORDA BUFFERS
        */

        // buffer creation for rain
        var rainBuffer = gl.createBuffer();

        init();

        // uutualizes teh initial values of glmatrix -- initial
        function init()
        {

            // enabling vertex attrib arrays
            gl.enableVertexAttribArray(vertexPositionPtr);
            gl.enableVertexAttribArray(vertexColorPtr);
            gl.enableVertexAttribArray(vertexSizePtr);
            gl.enable(gl.DEPTH_TEST);
        }

        /*
        *  Sets up the buffers, buffer data, and vertex pointers right before drawing.
        */
        function InitDrawVariables(buffer, points)
        {
            // SETTING UP BUFFERS ETC
            // binding the buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            // setting the data for the buffer
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(points), gl.STATIC_DRAW);
            

            /*
            * FOR INTERPRETING THE DATA
            */

            // POSITION
            var stride = 0;
            var offset = 9 * Float32Array.BYTES_PER_ELEMENT;

            gl.vertexAttribPointer(vertexPositionPtr, 4, gl.FLOAT, false, offset, stride);

            // COLOR
            stride = 4 * Float32Array.BYTES_PER_ELEMENT;
            // same offset as above
            gl.vertexAttribPointer(vertexColorPtr, 4, gl.FLOAT, false, offset, stride);

            // SIZE
            stride = 8 * Float32Array.BYTES_PER_ELEMENT;
            // same offset
            gl.vertexAttribPointer(vertexSizePtr, 1, gl.FLOAT, false, offset, stride);

        }

        /*
            Sets up the scene by clearing old screen and getting the transform matrix thingies + setting up what camera will look @
        */
        function setScene()
        {
            const near = -1;
            const far = 10;

            // setting up initial values/transform
            glMatrix.mat4.lookAt(viewMatrix, [0,0,-1,1], [0,0,1,1], [0,1,0,1]);
            // initial projection!
            glMatrix.mat4.ortho(projectionMatrix, -1, 1, -1, 1, near, far);

            
            console.log("cleared screen");
            gl.uniformMatrix4fv(transformPtr, false, new Float32Array(transformMatrix));

            //
            // dito iseset yung values ng uniform matrices.
            //
            gl.uniformMatrix4fv(modelPtr, false, new Float32Array(modelMatrix));
            gl.uniformMatrix4fv(viewPtr, false, new Float32Array(viewMatrix));
            gl.uniformMatrix4fv(projectionPtr, false, new Float32Array(projectionMatrix));

            // clear the screen
            gl.clearColor(0, 0, 0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

        }

        function update(delta)
        {
            // update y manually -- i think sa mat4.translate, yung buong buffer or buong space ng buffer yung nattranslate instead of
            // individual drops, which results in makikita mong gumagalaw lahat (even the newly created drops) as a unit / nagsspawn
            // sa space na nakikita ng user xd
            let sizeOfElement = 9;  // 9 floats per element
            for(let i=1;i<allRain.length;i+=sizeOfElement)
            {
                // update the y manually?
                allRain[i] -= delta;

                // note that bottom vertex (for the rain) is an odd index, while top is even
                // here we check if thie current vertex y is now past -1, meaning nasa bottom na
                // we remove that drop from the array, para di madami laman ni allrain
                if(i%2==0 && allRain[i] < -1)
                {
                    // indices to remove
                    // top = i-1 (x) to i+8
                    // bottom = i - sizeofelement - 1 (x) to i-2 (last element of bottom drop)
                    // 18 elements to remove
                    allRain.splice(i - sizeOfElement - 1, 18);
                }
            }
        }

        // Renders the scene repeatedly.
        function render(now)
        {
            const lenPerVertex = 8;    // 8 array elements per vertex
            now *= .001;    // converts to seconds
            // get dt
            dt = now - then;
            // update then
            then = now;

            // set camera
            setScene();
            
            // create and add to rain
            createRain(allRain);

            // draw scene w rain
            InitDrawVariables(rainBuffer, allRain);

            // DRAW
            gl.drawArrays(gl.LINES, 0, allRain.length/9);    // 8 is size of individual element arrays (4 pos, 4 color)

            // call function to update
            update(dt);

            requestAnimationFrame(render);
        }

        // render
        requestAnimationFrame(render);

        function createShader (gl, type, sourceCode) 
        {
            // Compiles either a shader of type gl.VERTEX_SHADER or gl.FRAGMENT_SHADER
            var shader = gl.createShader( type );
            gl.shaderSource( shader, sourceCode );
            gl.compileShader( shader );
            return shader;
        }

    </script>
</html>