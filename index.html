<!DOCTYPE html>
<html>
    <canvas id="output" width="728" height="942"></canvas>

    <script id="index" src="scripts/index.js"></script>
    <script id="rain" src="scripts/rain.js"></script>
    <script id="gl-matrix" src="scripts/gl-matrix.js"></script>

    <!-- SHADERS -->
    <script id="vertex-shader" type="notjs">#version 300 es
        in vec4 a_position;
        in float a_point_size;

        in vec4 in_Color;
        out vec4 v_Color;

        // transformation matrix here
        uniform mat4 u_transformation_matrix;

        // glmatrix things
        uniform mat4 model;
        uniform mat4 view;
        uniform mat4 projection;

        void main() {
            gl_Position = u_transformation_matrix * projection * view * model * a_position;
            gl_PointSize = a_point_size;

            // we basically output the input in_Color w/c will be used by frag shader
            v_Color = in_Color;
        }
    </script>

    <script id="fragment-shader" type="notjs">#version 300 es
        precision mediump float;
        
        // input will be same name as the output color name of the vshader
        in vec4 v_Color;

        // this will then apply the color thingy
        out vec4 out_Color;
        
        void main() {
            out_Color = v_Color;
        }
    </script>

    <!--MAIN-->
    <script>

        let then = 0;

        // initialize the gl and shit
        // gets the canvas w/c we will apply the script to
        const canvas = document.querySelector("#output");
        const gl = canvas.getContext("webgl2");
        //const glMatrix = document.querySelector("gl-matrix");

        // gets the source code sa <script>s sa taas
        const vertexShaderSource = document.querySelector('#vertex-shader').textContent;
        const fragmentShaderSource = document.querySelector('#fragment-shader').textContent;

        //creates and compiles the shaders
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

        // create and initialize the gl program.
        var program = gl.createProgram();

        // attach the vertex and fragment shaders
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);

        // link the program
        gl.linkProgram(program);
        gl.useProgram(program);

        /*
            MATRIX FOR TRANSFORMING STUFF ?
        */
       // we create the matrices here.
        const modelMatrix = glMatrix.mat4.create();
        const viewMatrix = glMatrix.mat4.create();
        const projectionMatrix = glMatrix.mat4.create();
        const near = -1;
        const far = 10;

        /*
            POINTERS
        */

        // we can access the pointers here already
        var vertexPositionPtr = gl.getAttribLocation(program, 'a_position');
        var vertexSizePtr = gl.getAttribLocation(program, 'a_point_size');
        var vertexColorPtr = gl.getAttribLocation(program, 'in_Color');
        // for affine transformationheadVertexCount
        var transformPtr = gl.getUniformLocation(program, 'u_transformation_matrix');

        // accessing the pointers for glMatrices here
        var modelPtr = gl.getUniformLocation(program, 'model');
        var viewPtr = gl.getUniformLocation(program, 'view');
        var projectionPtr = gl.getUniformLocation(program, 'projection');
        

        /* 
            FORDA BUFFERS
        */

        // buffer creation
        var rainBuffer = gl.createBuffer();

        init();
        InitDrawVariables(rainBuffer);

        // uutualizes teh initial values of glmatrix
        function init()
        {
            // setting up initial values/transform
            glMatrix.mat4.lookAt(viewMatrix, [0,0,1,1], [0,0,0,1], [0,1,0,1]);
            // initial projection!
            glMatrix.mat4.ortho(projectionMatrix, -1, 1, -1, 1, near, far);

            // enabling vertex attrib arrays
            gl.enableVertexAttribArray(vertexPositionPtr);
            gl.enableVertexAttribArray(vertexColorPtr);
            gl.enable(gl.DEPTH_TEST);
        }

        /*
        *  Sets up the buffers, buffer data, and vertex pointers right before drawing.
        */
        function InitDrawVariables(buffer)
        {
            // SETTING UP BUFFERS ETC
            // binding the buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

            /*
            * FOR INTERPRETING THE DATA
            */

            // POSITION
            var stride = 0;
            var offset = 8 * Float32Array.BYTES_PER_ELEMENT;

            gl.vertexAttribPointer(vertexPositionPtr, 4, gl.FLOAT, false, offset, stride);

            // COLOR
            stride = 4 * Float32Array.BYTES_PER_ELEMENT;        // after the position values
            // same offset as above
            gl.vertexAttribPointer(vertexColorPtr, 4, gl.FLOAT, false, offset, stride);

        }

        // Renders the scene repeatedly.
        function render(now)
        {
            const lenPerVertex = 8;    // 8 array elements per vertex
            now *= .001;
            // get dt
            dt = now - then;
            // update then
            then = now;

            // draw scene w rain
            InitDrawVariables(rainBuffer);
            draw(gl);

            // update the y position of rain in rainArr based on dt.
            for(let i=1;i<allRain.length;i += lenPerVertex + 1)
            {
                allRain[i] -= dt * 0.1;   // negative kasi pababa siya
            }

            requestAnimationFrame(render);
        }

        // render
        requestAnimationFrame(render);

        function createShader (gl, type, sourceCode) 
        {
            // Compiles either a shader of type gl.VERTEX_SHADER or gl.FRAGMENT_SHADER
            var shader = gl.createShader( type );
            gl.shaderSource( shader, sourceCode );
            gl.compileShader( shader );
            return shader;
        }

    </script>
</html>